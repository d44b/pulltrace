---
phase: 01-foundation-files
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/server/server.go
autonomous: true
requirements:
  - FIX-01
  - FIX-02

must_haves:
  truths:
    - "pulltrace_pull_errors_total counter increments when a pull completes with a non-empty Error field"
    - "LayerStatus.BytesPerSec is populated in processReport using a per-layer RateCalculator"
    - "LayerStatus.MediaType is copied from LayerState in processReport"
    - "Per-layer rate calculator entries are cleaned up when their parent pull is deleted from s.rates"
  artifacts:
    - path: "internal/server/server.go"
      provides: "Fixed processReport with layer rates + MediaType; PullErrors metric increment; layer rate cleanup"
      contains: "layerKey := key + \":layer:\""
  key_links:
    - from: "processReport() layer loop"
      to: "s.rates[layerKey]"
      via: "per-layer RateCalculator keyed by pullKey + ':layer:' + digest"
      pattern: "layerKey.*:layer:"
    - from: "processReport() pull completion block"
      to: "metrics.PullErrors.Inc()"
      via: "conditional on pull.Error != ''"
      pattern: "PullErrors\\.Inc"
    - from: "cleanup() pull deletion block"
      to: "s.rates[layerKey] deletion"
      via: "prefix scan for key + ':layer:'"
      pattern: "HasPrefix.*:layer:"
---

<objective>
Fix two production bugs in internal/server/server.go: (1) increment the PullErrors Prometheus counter when a pull completes with a non-empty Error field (FIX-01), and (2) populate LayerStatus.BytesPerSec and LayerStatus.MediaType in processReport using per-layer rate calculators (FIX-02), including cleanup of per-layer rate entries.

Purpose: FIX-01 makes the pull_errors_total counter actually useful for alerting. FIX-02 unblocks the LayerDetail UI component which already reads bytesPerSec and mediaType but currently receives zeroed values.
Output: Updated internal/server/server.go with both fixes applied.
</objective>

<execution_context>
@/Users/jmaciejewski/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jmaciejewski/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-files/01-RESEARCH.md
@internal/server/server.go
@internal/metrics/metrics.go
@internal/model/event.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Increment PullErrors counter on pull completion with error (FIX-01)</name>
  <files>internal/server/server.go</files>
  <action>
    Read internal/server/server.go first to confirm exact line numbers.

    In processReport(), find the block that marks absent pulls as completed (the "for key, pull := range s.pulls" loop near line ~455 where pull.CompletedAt is set). This is where pull completion events fire.

    After `metrics.PullBytesTotal.Add(float64(pull.TotalBytes))`, add:
    ```go
    if pull.Error != "" {
        metrics.PullErrors.Inc()
    }
    ```

    Context about pull.Error: PullStatus.Error exists in the model but is not currently populated by the agent or server. For v0.1.0, this increment is correct and defensive — if Error is ever set (by future agent changes or stale-pull logic), the counter will work. The counter will not fire in normal operation until Error population is implemented, which is acceptable per REQUIREMENTS.md scope.

    Do NOT add PullErrors.Inc() in the cleanup() stale-pull block — only in the processReport() completion path where pull.CompletedAt is explicitly set from the report processor. This keeps the semantics clean (error on a reported completion, not a timeout).

    Only modify this one location. Do not change surrounding logic.
  </action>
  <verify>
    <automated>grep -c "PullErrors.Inc" /Users/jmaciejewski/workspace/pulltrace/internal/server/server.go</automated>
    <manual>Confirm the PullErrors.Inc() call is inside an `if pull.Error != ""` block, placed after PullBytesTotal.Add in the processReport pull-completion loop.</manual>
  </verify>
  <done>server.go contains exactly one `metrics.PullErrors.Inc()` call, inside `if pull.Error != ""`, in the processReport pull-completion block (not cleanup).</done>
</task>

<task type="auto">
  <name>Task 2: Populate LayerStatus.BytesPerSec and MediaType, clean up layer rates (FIX-02)</name>
  <files>internal/server/server.go</files>
  <action>
    Read internal/server/server.go first to locate the exact layer loop in processReport() (~line 385) and the cleanup() function (~line 607).

    **Change 1: processReport() layer loop — add MediaType and BytesPerSec**

    In the existing `for _, layer := range pull.Layers` loop, the LayerStatus literal currently sets: PullID, Digest, TotalBytes, DownloadedBytes, TotalKnown. Update it to also set MediaType:
    ```go
    ls := model.LayerStatus{
        PullID:          key,
        Digest:          layer.Digest,
        MediaType:       layer.MediaType,   // ADD: copy from LayerState
        TotalBytes:      layer.TotalBytes,
        DownloadedBytes: layer.DownloadedBytes,
        TotalKnown:      layer.TotalKnown,
    }
    ```

    Immediately after constructing `ls`, add per-layer rate calculation using the same pattern as pull-level rates (s.rates map with model.NewRateCalculator). Key the entry as `key + ":layer:" + layer.Digest`:
    ```go
    layerKey := key + ":layer:" + layer.Digest
    lrc, ok := s.rates[layerKey]
    if !ok {
        lrc = model.NewRateCalculator(10 * time.Second)
        s.rates[layerKey] = lrc
    }
    lrc.Add(layer.DownloadedBytes)
    ls.BytesPerSec = lrc.Rate()
    ```

    Place this block after the `ls := model.LayerStatus{...}` literal and before the `if layer.TotalKnown && layer.TotalBytes > 0` percent calculation.

    **Change 2: cleanup() — delete per-layer rate entries when parent pull is removed**

    In cleanup(), after the existing three deletes for a completed pull:
    ```go
    delete(s.pulls, key)
    delete(s.rates, key)
    delete(s.lastSeen, key)
    ```

    Add a prefix scan to also clean up layer rate entries:
    ```go
    layerPrefix := key + ":layer:"
    for rateKey := range s.rates {
        if strings.HasPrefix(rateKey, layerPrefix) {
            delete(s.rates, rateKey)
        }
    }
    ```

    Confirm `strings` is already imported in the file (it is used elsewhere). If not, add it to the import block.

    Do not modify any other logic. These are additive changes only.
  </action>
  <verify>
    <automated>cd /Users/jmaciejewski/workspace/pulltrace && docker run --rm -v $(pwd):/app -w /app golang:1.22 go build ./internal/server/... 2>&1</automated>
    <manual>Confirm layerKey entries appear in s.rates during layer processing and are cleaned up on pull expiry. Read the modified processReport and cleanup() sections to verify correctness.</manual>
  </verify>
  <done>server.go compiles cleanly. processReport() sets MediaType from layer.MediaType, computes BytesPerSec via per-layer RateCalculator. cleanup() deletes all s.rates entries matching the `key + ":layer:"` prefix when a pull is removed.</done>
</task>

</tasks>

<verification>
1. `grep -c "PullErrors.Inc" internal/server/server.go` returns 1
2. `grep -c "layerKey.*:layer:" internal/server/server.go` returns 1 or more
3. `grep -c "HasPrefix.*:layer:" internal/server/server.go` returns 1
4. `grep -c "MediaType.*layer.MediaType" internal/server/server.go` returns 1
5. Docker build: `docker run --rm -v $(pwd):/app -w /app golang:1.22 go build ./internal/server/...` exits 0
</verification>

<success_criteria>
- server.go has PullErrors.Inc() inside `if pull.Error != ""` in the processReport completion block
- server.go sets `MediaType: layer.MediaType` in the LayerStatus literal in processReport's layer loop
- server.go adds per-layer RateCalculator keyed as `key + ":layer:" + layer.Digest` with BytesPerSec populated
- server.go cleanup() deletes all `key + ":layer:*"` entries from s.rates when a pull is deleted
- `docker run --rm -v $(pwd):/app -w /app golang:1.22 go build ./internal/server/...` exits 0
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-files/01-02-SUMMARY.md`
</output>
